#!/bin/bash

# Slack Integration Setup Script
# Configures Slack webhooks, creates channels, and sets up permissions

set -euo pipefail

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration file paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ALERTMANAGER_CONFIG="${PROJECT_ROOT}/deployments/kubernetes/alertmanager/configs"

# Default values
SLACK_WORKSPACE="${SLACK_WORKSPACE:-}"
SLACK_TOKEN="${SLACK_TOKEN:-}"
DRY_RUN="${DRY_RUN:-false}"

# Function to print colored output
log() {
    local level=$1
    shift
    case $level in
        "ERROR")
            echo -e "${RED}[ERROR]${NC} $*" >&2
            ;;
        "SUCCESS")
            echo -e "${GREEN}[SUCCESS]${NC} $*"
            ;;
        "INFO")
            echo -e "[INFO] $*"
            ;;
        "WARN")
            echo -e "${YELLOW}[WARN]${NC} $*"
            ;;
    esac
}

# Function to check prerequisites
check_prerequisites() {
    log "INFO" "Checking prerequisites..."
    
    # Check for required tools
    local required_tools=("curl" "jq" "kubectl")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log "ERROR" "$tool is required but not installed"
            exit 1
        fi
    done
    
    # Check for Slack token
    if [[ -z "$SLACK_TOKEN" ]]; then
        log "ERROR" "SLACK_TOKEN environment variable is not set"
        log "INFO" "Please export SLACK_TOKEN with your Slack app token"
        exit 1
    fi
    
    log "SUCCESS" "Prerequisites check passed"
}

# Function to create Slack channels
create_slack_channels() {
    log "INFO" "Creating Slack channels..."
    
    # Read channel list from configuration
    local channels=(
        "alerts"
        "alerts-prod"
        "alerts-staging"
        "alerts-dev"
        "ops-critical"
        "security-alerts"
        "database-alerts"
        "app-alerts"
        "infra-alerts"
        "after-hours-oncall"
        "maintenance-alerts"
        "test-alerts"
    )
    
    for channel in "${channels[@]}"; do
        if [[ "$DRY_RUN" == "true" ]]; then
            log "INFO" "[DRY RUN] Would create channel: #$channel"
        else
            log "INFO" "Creating channel: #$channel"
            
            # Create channel using Slack API
            response=$(curl -s -X POST "https://slack.com/api/conversations.create" \
                -H "Authorization: Bearer $SLACK_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"name\": \"$channel\", \"is_private\": false}")
            
            if [[ $(echo "$response" | jq -r '.ok') == "true" ]]; then
                log "SUCCESS" "Created channel: #$channel"
            elif [[ $(echo "$response" | jq -r '.error') == "name_taken" ]]; then
                log "INFO" "Channel already exists: #$channel"
            else
                log "ERROR" "Failed to create channel #$channel: $(echo "$response" | jq -r '.error')"
            fi
        fi
    done
}

# Function to create webhook for a channel
create_webhook() {
    local channel=$1
    local webhook_name=$2
    
    log "INFO" "Creating webhook for channel: #$channel"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "[DRY RUN] Would create webhook: $webhook_name for #$channel"
        echo "https://hooks.slack.com/services/DRYRUN/DRYRUN/DRYRUN"
    else
        # Note: This requires Slack app with incoming webhooks enabled
        # In practice, webhooks are usually created through Slack UI
        log "WARN" "Webhook creation via API requires OAuth app setup"
        log "INFO" "Please create webhook manually in Slack for channel: #$channel"
        log "INFO" "Webhook name: $webhook_name"
        echo ""
    fi
}

# Function to generate webhook configuration
generate_webhook_config() {
    log "INFO" "Generating webhook configuration..."
    
    local config_file="${ALERTMANAGER_CONFIG}/webhook-urls.env"
    
    cat > "$config_file" << EOF
# Slack Webhook URLs Configuration
# Generated by setup-slack-integration.sh on $(date)
# 
# IMPORTANT: Replace these placeholder URLs with actual webhook URLs from Slack
# To create webhooks:
# 1. Go to https://api.slack.com/apps
# 2. Select your app or create a new one
# 3. Enable Incoming Webhooks
# 4. Add webhooks for each channel below

# Default webhook for general alerts
SLACK_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

# Critical alerts webhook
SLACK_CRITICAL_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/CRITICAL/WEBHOOK"

# Team-specific webhooks
SLACK_DB_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/DATABASE/WEBHOOK"
SLACK_APP_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/APP/WEBHOOK"
SLACK_INFRA_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/INFRA/WEBHOOK"
SLACK_SECURITY_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/SECURITY/WEBHOOK"

# Optional: HTTP proxy for outbound connections
HTTP_PROXY_URL=""
EOF

    log "SUCCESS" "Generated webhook configuration at: $config_file"
    log "WARN" "Please update the webhook URLs in $config_file"
}

# Function to setup channel permissions
setup_channel_permissions() {
    log "INFO" "Setting up channel permissions..."
    
    # Define user groups and their channels
    declare -A channel_groups=(
        ["alerts"]="@all-employees"
        ["ops-critical"]="@ops-team @managers"
        ["security-alerts"]="@security-team @ops-team"
        ["database-alerts"]="@db-team @ops-team"
        ["app-alerts"]="@app-team @ops-team"
        ["infra-alerts"]="@infra-team @ops-team"
    )
    
    for channel in "${!channel_groups[@]}"; do
        local groups="${channel_groups[$channel]}"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            log "INFO" "[DRY RUN] Would add $groups to #$channel"
        else
            log "INFO" "Adding $groups to #$channel"
            # Note: Actual implementation would use Slack API to invite user groups
            log "WARN" "Manual setup required: Add $groups to #$channel"
        fi
    done
}

# Function to create Kubernetes secrets
create_kubernetes_secrets() {
    log "INFO" "Creating Kubernetes secrets for webhooks..."
    
    local namespace="${NAMESPACE:-monitoring}"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "[DRY RUN] Would create secret 'slack-webhooks' in namespace '$namespace'"
    else
        # Check if secret already exists
        if kubectl get secret slack-webhooks -n "$namespace" &> /dev/null; then
            log "WARN" "Secret 'slack-webhooks' already exists in namespace '$namespace'"
            read -p "Do you want to update it? (y/N) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log "INFO" "Skipping secret update"
                return
            fi
        fi
        
        # Create secret from env file
        if [[ -f "${ALERTMANAGER_CONFIG}/webhook-urls.env" ]]; then
            kubectl create secret generic slack-webhooks \
                --from-env-file="${ALERTMANAGER_CONFIG}/webhook-urls.env" \
                --namespace="$namespace" \
                --dry-run=client -o yaml | kubectl apply -f -
            
            log "SUCCESS" "Created/updated Kubernetes secret 'slack-webhooks'"
        else
            log "ERROR" "Webhook configuration file not found"
            exit 1
        fi
    fi
}

# Function to generate AlertManager configuration
generate_alertmanager_config() {
    log "INFO" "Generating AlertManager configuration..."
    
    local config_file="${ALERTMANAGER_CONFIG}/alertmanager-slack.yaml"
    
    cat > "$config_file" << 'EOF'
# AlertManager Configuration with Slack Integration
# This file should be used as the main AlertManager configuration

global:
  resolve_timeout: 5m
  slack_api_url_file: /etc/alertmanager/secrets/SLACK_WEBHOOK_URL

# Load template files
templates:
  - '/etc/alertmanager/templates/*.yaml'

# Main routing configuration
route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h
  receiver: 'default-slack'
  
  routes:
    # Include routing from slack-config.yaml
    - match:
        severity: critical
      receiver: 'slack-critical'
      continue: true

# Include receivers from slack-config.yaml
receivers:
  - name: 'default-slack'
    slack_configs:
      - api_url_file: /etc/alertmanager/secrets/SLACK_WEBHOOK_URL
        channel: '#alerts'
        send_resolved: true

# Inhibit rules
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'dev', 'instance']
EOF

    log "SUCCESS" "Generated AlertManager configuration at: $config_file"
}

# Function to test Slack integration
test_slack_integration() {
    log "INFO" "Testing Slack integration..."
    
    local test_webhook="${1:-$SLACK_WEBHOOK_URL}"
    
    if [[ -z "$test_webhook" || "$test_webhook" == "https://hooks.slack.com/services/YOUR/WEBHOOK/URL" ]]; then
        log "WARN" "No valid webhook URL provided for testing"
        log "INFO" "Please update webhook URLs first"
        return
    fi
    
    local test_message='{
        "text": "AlertManager Slack Integration Test",
        "attachments": [{
            "color": "good",
            "title": "Test Alert",
            "text": "This is a test message from AlertManager setup script",
            "fields": [
                {"title": "Status", "value": "Success", "short": true},
                {"title": "Time", "value": "'$(date)'", "short": true}
            ]
        }]
    }'
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "INFO" "[DRY RUN] Would send test message to Slack"
    else
        response=$(curl -s -X POST "$test_webhook" \
            -H "Content-Type: application/json" \
            -d "$test_message")
        
        if [[ "$response" == "ok" ]]; then
            log "SUCCESS" "Test message sent successfully"
        else
            log "ERROR" "Failed to send test message: $response"
        fi
    fi
}

# Function to print summary
print_summary() {
    log "INFO" "Setup Summary:"
    echo "======================================"
    echo "1. Channels to be created: Done"
    echo "2. Webhook configuration: ${ALERTMANAGER_CONFIG}/webhook-urls.env"
    echo "3. AlertManager config: ${ALERTMANAGER_CONFIG}/alertmanager-slack.yaml"
    echo ""
    echo "Next steps:"
    echo "1. Create webhooks in Slack UI"
    echo "2. Update webhook URLs in ${ALERTMANAGER_CONFIG}/webhook-urls.env"
    echo "3. Run: kubectl create secret generic slack-webhooks --from-env-file=${ALERTMANAGER_CONFIG}/webhook-urls.env -n monitoring"
    echo "4. Apply AlertManager configuration"
    echo "5. Test the integration"
    echo "======================================"
}

# Main execution
main() {
    log "INFO" "Starting Slack integration setup..."
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                log "INFO" "Running in dry-run mode"
                shift
                ;;
            --workspace)
                SLACK_WORKSPACE="$2"
                shift 2
                ;;
            --test)
                test_slack_integration "$2"
                exit 0
                ;;
            --help)
                echo "Usage: $0 [OPTIONS]"
                echo "Options:"
                echo "  --dry-run          Run without making actual changes"
                echo "  --workspace NAME   Specify Slack workspace"
                echo "  --test WEBHOOK     Test webhook integration"
                echo "  --help             Show this help message"
                exit 0
                ;;
            *)
                log "ERROR" "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Run setup steps
    check_prerequisites
    create_slack_channels
    generate_webhook_config
    setup_channel_permissions
    generate_alertmanager_config
    
    # Only create k8s secrets if not in dry-run mode
    if [[ "$DRY_RUN" != "true" ]]; then
        read -p "Do you want to create Kubernetes secrets now? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            create_kubernetes_secrets
        fi
    fi
    
    print_summary
    log "SUCCESS" "Slack integration setup completed!"
}

# Run main function
main "$@"